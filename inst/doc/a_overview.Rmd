---
title: "Overview for mand"
output:
  html_document:
    toc: true
    toc_float: true
    fig_width: 5
    fig_height: 5
  pdf_document:
    toc: true
    highlight: tango
    fig_width: 3
    fig_height: 3
  rmarkdown::html_vignette:
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Overview}
  %\VignetteEncoding[UTF-8]{inputenc}
---

<!--
%\VignetteEngine{knitr::knitr}
%\\VignetteIndexEntry{mand}
-->

`r Sys.Date()` @Atsushi Kawaguchi

The `mand` package provides functions for multivariate analysis for neuroimaging data. 
```{r}
library(mand)
```

# Introduction

## Template 
One subject image as the template is available in the mand package.
The coad to load it is as follows.
```{r}
data(template)
```

The image is compressed because of storage and computation time. The dimension is confirmed as follows.
```{r}
dim(template)
```

The image is plotted by the `coat` function. 
```{r}
coat(template)
```

Other options with the plane argument (such as "axial," "coronal," "sagittal," and "all") are available. The default setting is "axial".
If the argument is specified as `plane="all"`, three directional slices at a certain coordinate are plotted. 
```{r fig.width = 5, fig.height = 2}
coat(x=template, plane="all")
```

## Image Data Matrix
The `imgdatamat` function reads image files saved in the nifti format and creates data matrix with subjects in row and voxel in column (this example does not work).
```{r  eval=FALSE}
fnames1 = c("data1.nii", "data2.nii")
imgmat = imgdatamat(fnames1, simscale=1/4)
```
The first argument is file names with the length equaling the number of subjects (the number of rows in the resulting data matrix).
The second argument `simscale` is the image resize scale. In this example, the all sizes (number of voxel) for three direction was reduced into its quarter size.
The output is the list form where the "S" is data matrix, the "brainpos" is a binary image indicating brain region, and the "imagedim" is image dimension.
The ROI (Region Of Interest) volume is computed in the "roi" if the ROI argument is TRUE.
```{r  eval=FALSE}
imgmat = imgdatamat(fnames1, simscale=1/4, ROI=TRUE)
```


## Overlay
The resulting map from the statistical analysis such as the t statistics map from the SPM is represented with overlapping on the template.
For example, the `mand` package has the average difference assuming Alzheimer's disease and healthy subjects with the array format. 
```{r echo=FALSE, eval=FALSE}
'
```
The overlay is implemented by the `coat` function.
```{r}
data(diffimg)
coat(template, diffimg)
```

## Atlas
Anatomical brain segmentation region is useful for the plot and the interpretation.
For example, the Automated Anatomical Labeling (AAL) atlas is used. 
The data.frame has two columns ("ROIid" and "ROIname") format. 
```{r}
data(atlasdatasets)
atlasname = "aal"
atlasdataset = atlasdatasets[[atlasname]]
head(atlasdataset)
```

It is also neccesary to prepare the array data.
```{r}
data(atlas)
tmpatlas = atlas[[atlasname]]
dim(tmpatlas)
```

It has the ROIid as the element.
```{r}
tmpatlas[11:15,11:15,10]
```

The anatomical region can be plotted by the `coat` function with regionplot=TRUE.
```{r}
coat(template, tmpatlas, regionplot=TRUE, 
atlasdataset=atlasdataset, ROIids = c(1:2, 37:40), 
regionlegend=TRUE)
```


The resulting map can be converted into the summary of the anatomical regions.
```{r}
atlastable(tmpatlas, diffimg, atlasdataset, ROIids = c(1:2, 
37:40))
```

The outputs are the number of voxel in the `sizenum` column,
the percentage of the voxel in the `sizepct` column, and
the minimum, mean, and maximum valued of the region of the overlaying map.
The order of the table row is in the larger absolute value of the minimum or maximum values.

The brain image corresponding to the region of interest can be extracted as follows.
First, we create a mask image in which the hippocampal region is represented by 1 and others by 0.
Then the product of the template and the mask image is taken for each voxel.
```{r} 
hipmask = (tmpatlas == 37) + (tmpatlas == 38)
template2 = template * hipmask
```

The images generated by these processes are plotted from left to right in one slice.
```{r fig.width = 5, fig.height = 2}
par(mfrow=c(1,3), mar=rep(1,4))
coat(template, pseq=11, paron=FALSE)
coat(hipmask, pseq=11, paron=FALSE)
coat(template2, pseq=11, paron=FALSE)
```

The template image (left) and the mask image (middle) are multiplied voxel by voxel to obtain the only hippocampus region image (right).

The sum of the voxel values in the region is calculated as follows.
```{r}
sum(template[which(hipmask==1, arr.ind = TRUE)])/1000
```

Such a value is calculated for each region and a dataset with ROI values is created.


# Principal Component Analysis ####################################################################################################

## Generate Simulation Data
The `mand` package has a function to generate simulation brain data from the base image, the difference image and the standard deviation image.
These basic images are loaded as follows.
```{r}
data(baseimg)
data(diffimg)
data(mask)
data(sdevimg)
```

The number of voxels in the original 3D image is as follows.
```{r}
dim(baseimg)
```

To understand the result easily, the difference region was restricted to Parahippocampus and Hippocampus.
```{r}
diffimg2 = diffimg * (tmpatlas %in% 37:40)
```

An image data matrix with subjects in the rows and voxels in the columns was generated by using the `simbrain` function.
```{r}
img1 = simbrain(baseimg = baseimg, diffimg = diffimg2, 
sdevimg=sdevimg, mask=mask, n0=20, c1=0.01, sd1=0.05)
```

The base image, the difference image and the standard deviation image were specified in the first three arguments. The out-of-brain region was specified by the mask argument, which was the binary image. The remaining arguments are the number of subjects per group, the coefficient multiplied by the difference image and the standard deviation for the noise.

The data matrix dimension was `r nrow(img1$S)`(subject) x `r ncol(img1$S)`(voxel).
```{r}
dim(img1$S)
```

The `rec` function creates the 3D image from the vectorized data (the first subject).
```{r}
coat(rec(img1$S[1,], img1$imagedim, mask=img1$brainpos))
```

The standard deviation image is created from the resulting data matrix.
```{r}
sdimg = apply(img1$S, 2, sd)
coat(template, rec(sdimg, img1$imagedim, mask=img1$brainpos))
```

## Principal Component Analysis ##############################################################################################################

If the input is a matrix, a principal component analysis is implemented by the `msma` function of the `msma` package.
Principal component analysis with the number of components of 2 for the image data matrix is performed as follows.
```{r}
(fit111 = msma(img1$S, comp=2))
```

The scatter plots for the score vectors specified by the argument `v`.
The argument `axes` is specified by the two length vectors on which components are displayed.
```{r}
plot(fit111, v="score", axes = 1:2, plottype="scatter")
```

The weight (loading) vectors can be obtained and reconstructed as follows.
```{r}
midx = 1 ## the index for the modality
vidx = 1 ## the index for the component
Q = fit111$wbX[[midx]][,vidx]
outstat1 = rec(Q, img1$imagedim, mask=img1$brainpos)
```

The reconstructed loadings as image is overlayed on the template.
```{r}
coat(template, outstat1)
```

The output is unclear; however, this will be improved later.

# Two-steps dimension reduction ####################################################################################################

## Basis Expansion

This is an example of the two-step dimension reduction.

Generate radial basis function. 
```{r}
B1 = rbfunc(imagedim=img1$imagedim, seppix=2, hispec=FALSE, 
mask=img1$brainpos)
```

Multiplying the basis function to image data matrix.
```{r}
SB1 = basisprod(img1$S, B1)
```

The original dimension was `r dim(img1$S)[2]`.
```{r}
dim(img1$S)
```

The dimension was reduced to `r dim(SB1)[2]`.
```{r}
dim(SB1)
```


## Principal Component Analysis

The Principal Component Analysis (PCA) is applied to the dimension-reduced image.
```{r}
(fit211 = msma(SB1, comp=2))
```

The loading is reconstructed to the original space by using the `rec` function.
```{r}
Q = fit211$wbX[[1]][,1]
outstat1 = rec(Q, img1$imagedim, B=B1, mask=img1$brainpos)
```

The plotted (sign-flipping) loading is smoother than the one without the dimension reduction by the basis function.
```{r}
outstat2 = -outstat1
coat(template, outstat2)
```

## Sparse PCA

If `lambdaX` (>0) is specified, a sparse principal component analysis is implemented.
```{r}
(fit112 = msma(SB1, comp=2, lambdaX=0.075))
```

The plotted loading is narrower than that from the PCA.
```{r}
Q = fit112$wbX[[midx]][,vidx]
outstat1 = rec(Q, img1$imagedim, B=B1, mask=img1$brainpos)
outstat2 = outstat1
coat(template, outstat2)
```

The region is reported as follows to be compared with the next method.
```{r}
atlastable(tmpatlas, outstat2, atlasdataset)
```


## Supervised Sparse PCA

The `simbrain` generates the synthetic brain image data and the binary outcome. The outcome Z is obtained.
```{r}
Z = img1$Z
```

If the outcome Z is specified in the `msma` function, a supervised sparse principal component analysis is implemented.
```{r}
(fit113 = msma(SB1, Z=Z, comp=2, lambdaX=0.075, muX=0.5))
```

The plotted loading is located differently from the sparse PCA.
```{r}
Q = fit113$wbX[[1]][,1]
outstat1 = rec(Q, img1$imagedim, B=B1, mask=img1$brainpos)
outstat2 = -outstat1
coat(template, outstat2)
```

The region near the hippocampus, which differs from the sparse PCA (without supervision).
```{r}
atlastable(tmpatlas, outstat2, atlasdataset)
```

The loading for the second component 
```{r}
Q = fit113$wbX[[1]][,2]
outstat1 = rec(Q, img1$imagedim, B=B1, mask=img1$brainpos)
outstat2 = -outstat1
coat(template, outstat2)
```

```{r}
atlastable(tmpatlas, outstat2, atlasdataset)
```

This is similar to the result from the sparse PCA (without supervision).

The following method can be used to plot the weights of several components simultaneously.
It is first reconstructed in three dimensions with the `multirec` function and then plotted with the `multicompplot` function.
It is set to display four columns per component.
```{r fig.width = 7, fig.height = 6.5}
ws = multirec(fit113, imagedim=img1$imagedim, B=B1, 
mask=img1$brainpos)
multicompplot(ws, template, col4comp=4)
```
